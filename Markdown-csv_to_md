import csv
import os
from collections import Counter

# Force le r√©pertoire de travail √† √™tre celui o√π se trouve le script
os.chdir(os.path.dirname(os.path.abspath(__file__)))

def interpret_flags(packet_info):
    """Traduit les drapeaux TCP en texte compr√©hensible pour le rapport."""
    if "Flags [S]" in packet_info: return "Requ√™te de connexion (SYN)"
    if "Flags [P.]" in packet_info: return "Transfert de donn√©es (PUSH-ACK)"
    if "Flags [.]" in packet_info: return "Accus√© de r√©ception (ACK)"
    if "Flags [R]" in packet_info: return "Connexion refus√©e (RST)"
    if "ICMP" in packet_info: return "Ping / Diagnostic r√©seau"
    return "Autre protocole"

def generate_final_report(input_csv, output_md):
    try:
        if not os.path.exists(input_csv):
            print(f"Erreur : le fichier {input_csv} est introuvable.")
            return

        with open(input_csv, 'r', encoding='utf-8') as f:
            # Utilisation du d√©limiteur ';' selon le format CSV/Excel habituel
            reader = csv.DictReader(f, delimiter=';')
            packets = list(reader)

        if not packets:
            print("Erreur : le fichier CSV est vide.")
            return

        # --- ANALYSE AVANC√âE ---

        # 1. Analyse d√©taill√©e SSH (v√©rifie la pr√©sence de .ssh ou du port 22 dans la destination)
        ssh_sources = [p['Source'] for p in packets if '.ssh' in p['Destination'] or '.22' in p['Destination']]
        ssh_counts = Counter(ssh_sources)

        # 2. D√©tection de scan de ports (compte le nombre de ports de destination uniques)
        dest_ports = [p['Destination'].split('.')[-1] for p in packets]
        unique_dest_ports = len(set(dest_ports))

        # 3. Trafic ICMP (Ping)
        icmp_packets = [p for p in packets if "ICMP" in p['Packet_Info']]

        # --- G√âN√âRATION DU RAPPORT MARKDOWN ---
        with open(output_md, 'w', encoding='utf-8') as md:
            md.write("# üõ°Ô∏è Rapport global de s√©curit√© r√©seau\n\n")

            md.write("## 1. Menace critique : attaque SSH cibl√©e\n")
            md.write("L‚Äôoutil a identifi√© un sch√©ma d‚Äôattaque multi-√©tapes provenant de `192.168.190.130` :\n")

            if not ssh_counts:
                md.write("- ‚úÖ Aucune menace SSH sp√©cifique d√©tect√©e dans cet √©chantillon.\n")
            else:
                for source, count in ssh_counts.items():
                    if count >= 60:
                        md.write(f"- üî¥ **Assaut principal** : le port `{source}` a g√©n√©r√© **{count} paquets**. Activit√© de force brute confirm√©e.\n")
                    elif 4 <= count <= 10:
                        md.write(f"- üü† **Test de connexion** : le port `{source}` a g√©n√©r√© **{count} paquets** (v√©rification de service).\n")
                    else:
                        md.write(f"- üü° **Sonde discr√®te** : le port `{source}` a g√©n√©r√© **{count} paquets**.\n")

            md.write("\n## 2. Autres anomalies d√©tect√©es\n")

            # Alerte de scan de ports
            if unique_dest_ports > 15:
                md.write(f"- ‚ö†Ô∏è **Scan de ports** : l‚Äôh√¥te a sond√© **{unique_dest_ports}** ports diff√©rents. Activit√© de reconnaissance d√©tect√©e.\n")

            # Alerte ICMP
            if len(icmp_packets) > 50:
                md.write(f"- ‚ö†Ô∏è **Flood ICMP** : {len(icmp_packets)} paquets Ping d√©tect√©s. Risque potentiel de saturation r√©seau.\n")

            # Alerte de volume de trafic
            if len(packets) > 10000:
                md.write(f"- ‚ö†Ô∏è **Volume de trafic √©lev√©** : {len(packets)} paquets analys√©s au total. Risque possible de d√©ni de service (DoS).\n")

            md.write("\n## 3. √âchantillon de trafic et interpr√©tation\n")
            md.write("| Horodatage | Source | Signification du drapeau | R√©sum√© technique |\n")
            md.write("| :--- | :--- | :--- | :--- |\n")

            # Affiche les 40 premi√®res lignes ‚Äî en utilisant 'Timestamp' ou 'Heure' selon la colonne disponible
            for p in packets[:40]:
                # Utilisation de .get() pour √©viter une erreur si le nom de colonne varie
                time_val = p.get('Timestamp', p.get('Heure', 'N/A'))
                info_val = p.get('Packet_Info', p.get('Info_Paquet', 'N/A'))

                md.write(f"| {time_val} | {p['Source']} | **{interpret_flags(info_val)}** | {info_val[:55]}... |\n")

        print(f"Succ√®s ! Le rapport '{output_md}' a √©t√© g√©n√©r√© avec succ√®s.")

    except Exception as e:
        print(f"Erreur : {e}")

if __name__ == "__main__":
    # Nom exact du fichier d'entr√©e √† utiliser
    generate_final_report('Network_Analysis.csv', 'Network_Report.md')
